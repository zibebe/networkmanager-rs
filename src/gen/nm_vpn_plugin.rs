// This code was autogenerated with `dbus-codegen-rust -m None`, see https://github.com/diwic/dbus-rs
use dbus::arg;
use dbus::blocking;

pub trait OrgFreedesktopNetworkManagerVPNPlugin {
    fn connect(
        &self,
        connection: ::std::collections::HashMap<
            &str,
            ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
        >,
    ) -> Result<(), dbus::Error>;
    fn connect_interactive(
        &self,
        connection: ::std::collections::HashMap<
            &str,
            ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
        >,
        details: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
    ) -> Result<(), dbus::Error>;
    fn need_secrets(
        &self,
        settings: ::std::collections::HashMap<
            &str,
            ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
        >,
    ) -> Result<String, dbus::Error>;
    fn disconnect(&self) -> Result<(), dbus::Error>;
    fn set_config(
        &self,
        config: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
    ) -> Result<(), dbus::Error>;
    fn set_ip4_config(
        &self,
        config: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
    ) -> Result<(), dbus::Error>;
    fn set_ip6_config(
        &self,
        config: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
    ) -> Result<(), dbus::Error>;
    fn set_failure(&self, reason: &str) -> Result<(), dbus::Error>;
    fn new_secrets(
        &self,
        connection: ::std::collections::HashMap<
            &str,
            ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
        >,
    ) -> Result<(), dbus::Error>;
    fn state(&self) -> Result<u32, dbus::Error>;
}

impl<'a, C: ::std::ops::Deref<Target = blocking::Connection>> OrgFreedesktopNetworkManagerVPNPlugin
    for blocking::Proxy<'a, C>
{
    fn connect(
        &self,
        connection: ::std::collections::HashMap<
            &str,
            ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
        >,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.NetworkManager.VPN.Plugin",
            "Connect",
            (connection,),
        )
    }

    fn connect_interactive(
        &self,
        connection: ::std::collections::HashMap<
            &str,
            ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
        >,
        details: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.NetworkManager.VPN.Plugin",
            "ConnectInteractive",
            (connection, details),
        )
    }

    fn need_secrets(
        &self,
        settings: ::std::collections::HashMap<
            &str,
            ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
        >,
    ) -> Result<String, dbus::Error> {
        self.method_call(
            "org.freedesktop.NetworkManager.VPN.Plugin",
            "NeedSecrets",
            (settings,),
        )
        .and_then(|r: (String,)| Ok(r.0))
    }

    fn disconnect(&self) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.NetworkManager.VPN.Plugin",
            "Disconnect",
            (),
        )
    }

    fn set_config(
        &self,
        config: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.NetworkManager.VPN.Plugin",
            "SetConfig",
            (config,),
        )
    }

    fn set_ip4_config(
        &self,
        config: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.NetworkManager.VPN.Plugin",
            "SetIp4Config",
            (config,),
        )
    }

    fn set_ip6_config(
        &self,
        config: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.NetworkManager.VPN.Plugin",
            "SetIp6Config",
            (config,),
        )
    }

    fn set_failure(&self, reason: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.NetworkManager.VPN.Plugin",
            "SetFailure",
            (reason,),
        )
    }

    fn new_secrets(
        &self,
        connection: ::std::collections::HashMap<
            &str,
            ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
        >,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.NetworkManager.VPN.Plugin",
            "NewSecrets",
            (connection,),
        )
    }

    fn state(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.NetworkManager.VPN.Plugin",
            "State",
        )
    }
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerVPNPluginStateChanged {
    pub state: u32,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerVPNPluginStateChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.state, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerVPNPluginStateChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerVPNPluginStateChanged { state: i.read()? })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerVPNPluginStateChanged {
    const NAME: &'static str = "StateChanged";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager.VPN.Plugin";
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerVPNPluginSecretsRequired {
    pub message: String,
    pub secrets: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerVPNPluginSecretsRequired {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.message, i);
        arg::RefArg::append(&self.secrets, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerVPNPluginSecretsRequired {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerVPNPluginSecretsRequired {
            message: i.read()?,
            secrets: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerVPNPluginSecretsRequired {
    const NAME: &'static str = "SecretsRequired";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager.VPN.Plugin";
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerVPNPluginConfig {
    pub config: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerVPNPluginConfig {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.config, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerVPNPluginConfig {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerVPNPluginConfig { config: i.read()? })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerVPNPluginConfig {
    const NAME: &'static str = "Config";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager.VPN.Plugin";
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerVPNPluginIp4Config {
    pub ip4config:
        ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerVPNPluginIp4Config {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.ip4config, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerVPNPluginIp4Config {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerVPNPluginIp4Config {
            ip4config: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerVPNPluginIp4Config {
    const NAME: &'static str = "Ip4Config";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager.VPN.Plugin";
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerVPNPluginIp6Config {
    pub ip6config:
        ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerVPNPluginIp6Config {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.ip6config, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerVPNPluginIp6Config {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerVPNPluginIp6Config {
            ip6config: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerVPNPluginIp6Config {
    const NAME: &'static str = "Ip6Config";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager.VPN.Plugin";
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerVPNPluginLoginBanner {
    pub banner: String,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerVPNPluginLoginBanner {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.banner, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerVPNPluginLoginBanner {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerVPNPluginLoginBanner { banner: i.read()? })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerVPNPluginLoginBanner {
    const NAME: &'static str = "LoginBanner";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager.VPN.Plugin";
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerVPNPluginFailure {
    pub reason: u32,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerVPNPluginFailure {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.reason, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerVPNPluginFailure {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerVPNPluginFailure { reason: i.read()? })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerVPNPluginFailure {
    const NAME: &'static str = "Failure";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager.VPN.Plugin";
}
